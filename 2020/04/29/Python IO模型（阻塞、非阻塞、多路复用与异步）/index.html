

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/logo.png">
  <link rel="icon" href="/img/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="waymingz">
  <meta name="keywords" content="">
  
    <meta name="description" content="IO模型　　同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同环境下给出的答案也是不一的。所以先限定一下上下文是非常有必要的。 本文讨论的背景是Linux环境下的network IO。 在深入了解之前，我们应先了解几个概念：  用户空间和内核空间　 - 进程切换　 - 进程的阻塞　 - 文件描述符　 - 缓存 I&#x2F;O 用户空间与内核空间 　　现在操作系统都是采用">
<meta property="og:type" content="article">
<meta property="og:title" content="Python IO模型（阻塞、非阻塞、多路复用与异步）">
<meta property="og:url" content="https://waym1ng.github.io/2020/04/29/Python%20IO%E6%A8%A1%E5%9E%8B%EF%BC%88%E9%98%BB%E5%A1%9E%E3%80%81%E9%9D%9E%E9%98%BB%E5%A1%9E%E3%80%81%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E5%BC%82%E6%AD%A5%EF%BC%89/index.html">
<meta property="og:site_name" content="MingMing&#39;blog">
<meta property="og:description" content="IO模型　　同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同环境下给出的答案也是不一的。所以先限定一下上下文是非常有必要的。 本文讨论的背景是Linux环境下的network IO。 在深入了解之前，我们应先了解几个概念：  用户空间和内核空间　 - 进程切换　 - 进程的阻塞　 - 文件描述符　 - 缓存 I&#x2F;O 用户空间与内核空间 　　现在操作系统都是采用">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDQvMTA1MDM5My0yMDE3MDQxNTIxMTkxNzg0NS04NzI2MjYyNzEucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDAxNTI5Ny0xNDIwNDg3Nzc5LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDIxNDg3NS0xNzA4MDgwMTk2LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDMzMTQ2OS0xMzk0OTM5NzY2LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDMzMTQ2OS0xMzk0OTM5NzY2LnBuZw?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDUxOTczNC0yNjMyNDAxNDkucG5n?x-oss-process=image/format,png">
<meta property="og:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDcyMjg5MS0xMjc5Nzk2NzE5LnBuZw?x-oss-process=image/format,png">
<meta property="article:published_time" content="2020-04-29T02:03:47.000Z">
<meta property="article:modified_time" content="2024-03-27T12:19:28.338Z">
<meta property="article:author" content="waymingz">
<meta property="article:tag" content="epoll python linux">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDQvMTA1MDM5My0yMDE3MDQxNTIxMTkxNzg0NS04NzI2MjYyNzEucG5n?x-oss-process=image/format,png">
  
  
  
  <title>Python IO模型（阻塞、非阻塞、多路复用与异步） - MingMing&#39;blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"waym1ng.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"QaAc8EraW3qDuc3hldMvmw5p-gzGzoHsz","app_key":"oTgXIx2IwXcYJAPXLGPAdYJC","server_url":"https://qaac8era.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>明明的博客呀</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Python IO模型（阻塞、非阻塞、多路复用与异步）"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2020-04-29 10:03" pubdate>
          2020年4月29日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          144 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Python IO模型（阻塞、非阻塞、多路复用与异步）</h1>
            
            
              <div class="markdown-body">
                
                <span id="more"></span>

<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><p>　　同步IO和异步IO，阻塞IO和非阻塞IO分别是什么，到底有什么区别？不同环境下给出的答案也是不一的。所以先限定一下上下文是非常有必要的。</p>
<p><em><code>本文讨论的背景是Linux环境下的network IO。</code></em></p>
<p><strong>在深入了解之前，我们应先了解几个概念：</strong></p>
<p> 用户空间和内核空间<br>　 - 进程切换<br>　 - 进程的阻塞<br>　 - 文件描述符<br>　 - 缓存 I&#x2F;O</p>
<p><strong>用户空间与内核空间</strong></p>
<p>　　现在操作系统都是采用虚拟存储器，那么对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。针对linux操作系统而言，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。</p>
<p> </p>
<p><strong>进程切换</strong></p>
<p>　　为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。这种行为被称为进程切换。因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<p>从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：<br>　　1. 保存处理机上下文，包括程序计数器和其他寄存器。<br>　　2. 更新PCB信息。</p>
<p>　　3. 把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。<br>　　4. 选择另一个进程执行，并更新其PCB。<br>　　5. 更新内存管理的数据结构。<br>　　6. 恢复处理机上下文。</p>
<p>总而言之就是很耗资源，具体的可以参考这篇文章：<a target="_blank" rel="noopener" href="http://guojing.me/linux-kernel-architecture/posts/process-switch/">进程切换</a></p>
<p>_注：进程控制块（Processing Control Block），是<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/880.htm">操作系统</a><a target="_blank" rel="noopener" href="http://baike.baidu.com/view/22680.htm">核心</a>中一种数据结构，主要表示<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/19746.htm">进程</a>状态。其作用是使一个在<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/1189611.htm">多道程序</a>环境下不能独立运行的程序（含数据），成为一个能独立运行的基本单位或与其它进程并发执行的进程。或者说，OS是根据PCB来对并发执行的进程进行控制和管理的。 PCB通常是系统内存占用区中的一个连续存区，它存放着<a target="_blank" rel="noopener" href="http://baike.baidu.com/view/880.htm">操作系统</a>用于描述进程情况及控制进程运行所需的全部信息 _</p>
<p><strong>进程的阻塞</strong></p>
<p>　　正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<code>当进程进入阻塞状态，是不占用CPU资源的</code>。</p>
<p><strong>文件描述符fd</strong></p>
<p>　　文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>
<p>　　文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。在程序设计中，一些涉及底层的程序编写往往会围绕着文件描述符展开。但是文件描述符这一概念往往只适用于UNIX、Linux这样的操作系统。</p>
<p> </p>
<p><strong>缓存 I&#x2F;O</strong></p>
<p>　　缓存 I&#x2F;O 又被称作标准 I&#x2F;O，大多数文件系统的默认 I&#x2F;O 操作都是缓存 I&#x2F;O。在 Linux 的缓存 I&#x2F;O 机制中，操作系统会将 I&#x2F;O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。</p>
<p>缓存 I&#x2F;O 的缺点：<br>　　数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p>
<h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：<br>　　1. 等待数据准备 (Waiting for the data to be ready)<br>　　2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDQvMTA1MDM5My0yMDE3MDQxNTIxMTkxNzg0NS04NzI2MjYyNzEucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p><em>详细：<a target="_blank" rel="noopener" href="http://blog.csdn.net/haiross/article/details/39078853">http://blog.csdn.net/haiross/article/details/39078853</a></em></p>
<p> </p>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。<br>　 - 阻塞 I&#x2F;O（blocking IO）<br>　 - 非阻塞 I&#x2F;O（nonblocking IO）<br>　 - I&#x2F;O 多路复用（ IO multiplexing）<br>　 - 信号驱动 I&#x2F;O（ signal driven IO）<br>　 - 异步 I&#x2F;O（asynchronous IO）</p>
<p>注：由于signal driven IO在实际中并不常用，所以我这只提及剩下的四种IO Model。</p>
<p> </p>
<p><strong>阻塞 I&#x2F;O（blocking IO）</strong></p>
<p>阻塞I&#x2F;O模型是最广泛的模型，在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDAxNTI5Ny0xNDIwNDg3Nzc5LnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>　　当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p>
<p>　**　所以，blocking IO的特点就是在IO执行的两个阶段都被block了。**</p>
<p>** 注意：进程处于阻塞模式时，让出CPU，进入休眠状态。**</p>
<p> </p>
<p><strong>非阻塞 I&#x2F;O（nonblocking IO）</strong></p>
<p>linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：</p>
<p> </p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDIxNDg3NS0xNzA4MDgwMTk2LnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>　　当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p>
<p>　　<strong>所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有。</strong></p>
<p>阻塞IO与非阻塞IO的性能区别</p>
<p>　　在阻塞模式下，若从网络流中读取不到指定大小的数据量，阻塞IO就在那里阻塞着。比如，已知后面会有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就在那傻傻地等到下一个字节的到来，对，就在那等着，啥事也不做，直到把这10个字节读取完，这才将阻塞放开通行。</p>
<p>　　在非阻塞模式下，若从网络流中读取不到指定大小的数据量，非阻塞IO就立即通行。比如，已知后面会有10个字节的数据发过来，但是我现在只收到8个字节，那么当前线程就读取这8个字节的数据，读完后就立即返回，等另外两个字节再来的时候再去读取。</p>
<p>　　从上面可以看出，阻塞IO在性能方面是很低下的，如果要使用阻塞IO完成一个Web服务器的话，那么对于每一个请求都必须启用一个线程进行处理。而使用非阻塞IO的话，一到两个线程基本上就够了，因为线程不会产生阻塞，好比一下接收A请求的数据，另一下接收B请求的数据，等等，就是不停地东奔西跑，直接到把数据接收完了。</p>
<p><strong>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回！</strong></p>
<p><strong><strong>注意；非阻塞模式的使用并不普遍，因为非阻塞模式会浪费大量的CPU资源。</strong></strong></p>
<p> </p>
<p><strong>I&#x2F;O 多路复用（ IO multiplexing）</strong></p>
<p>　　多路复用的本质是同步非阻塞I&#x2F;O，多路复用的优势并不是单个连接处理的更快，而是在于能处理更多的连接。</p>
<p>　　I&#x2F;O编程过程中，需要同时处理多个客户端接入请求时，可以利用多线程或者I&#x2F;O多路复用技术进行处理。 I&#x2F;O多路复用技术通过把多个I&#x2F;O的阻塞复用到同一个select阻塞上，一个进程监视多个描述符，一旦某个描述符就位， 能够通知程序进行读写操作。因为多路复用本质上是同步I&#x2F;O，都需要应用程序在读写事件就绪后自己负责读写。 与传统的多线程&#x2F;多进程模型比，I&#x2F;O多路复用的最大优势是系统开销小，系统不需要创建新的额外进程或者线程。</p>
<ul>
<li>应用场景<ul>
<li>服务器需要同时处理多个处于监听状态或者多个连接状态的套接字</li>
<li>需要同时处理多种网络协议的套接字</li>
<li>一个服务器处理多个服务或协议</li>
</ul>
</li>
</ul>
<p>目前支持多路复用的系统调用有 <code>select</code> , <code>poll</code> , <code>epoll</code> 。</p>
<p>　　IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select&#x2F;epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDMzMTQ2OS0xMzk0OTM5NzY2LnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDMzMTQ2OS0xMzk0OTM5NzY2LnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>**<code>　　当用户进程调用了select，那么整个进程会被block</code>**，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p>
<p>　　<strong>所以，I&#x2F;O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</strong></p>
<p>　　这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，用select的优势在于它可以同时处理多个connection。</p>
<p>　　所以，如果处理的连接数不是很高的话，使用select&#x2F;epoll的web server不一定比使用multi-threading + blocking IO的web server性能更好，可能延迟还更大。select&#x2F;epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。）</p>
<p>　　在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p>
<p> </p>
<p><strong>异步 I&#x2F;O（asynchronous IO）</strong></p>
<p>　　相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的<a target="_blank" rel="noopener" href="http://lib.csdn.net/base/architecture">架构</a>基本可以满足需求</p>
<p>linux下的asynchronous IO其实用得很少。先看一下它的流程：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDUxOTczNC0yNjMyNDAxNDkucG5n?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>　　用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p><em>浅析 I&#x2F;O 模型及其设计模式<a target="_blank" rel="noopener" href="http://blog.jobbole.com/104638/">http://blog.jobbole.com/104638/</a></em></p>
<p>blocking和non-blocking的区别</p>
<p>调用blocking IO会一直block住对应的进程直到操作完成，而non-blocking IO在kernel还准备数据的情况下会立刻返回。</p>
<p>synchronous IO和asynchronous IO的区别</p>
<p><strong>同步IO和异步IO的区别就在于：数据访问的时候进程是否阻塞！</strong></p>
<p>在说明synchronous IO和asynchronous IO的区别之前，需要先给出两者的定义。POSIX的定义是这样子的：<br>　 - A synchronous I&#x2F;O operation causes the requesting process to be blocked until that I&#x2F;O operation completes;<br>　 - An asynchronous I&#x2F;O operation does not cause the requesting process to be blocked;</p>
<p>　　两者的区别就在于synchronous IO做”IO operation”的时候会将process阻塞。按照这个定义，之前所述的blocking IO，non-blocking IO，IO multiplexing都属于synchronous IO。</p>
<p>　　有人会说，non-blocking IO并没有被block啊。这里有个非常“狡猾”的地方，定义中所指的”IO operation”是指真实的IO操作，就是例子中的recvfrom这个system call。non-blocking IO在执行recvfrom这个system call的时候，如果kernel的数据没有准备好，这时候不会block进程。但是，当kernel中数据准备好的时候，recvfrom会将数据从kernel拷贝到用户内存中，这个时候进程是被block了，在这段时间内，进程是被block的。</p>
<p>　　而asynchronous IO则不一样，当进程发起IO 操作之后，就直接返回再也不理睬了，直到kernel发送一个信号，告诉进程说IO完成。在这整个过程中，进程完全没有被block。</p>
<p> </p>
<p>各个IO Model的比较如图所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWFnZXMyMDE1LmNuYmxvZ3MuY29tL2Jsb2cvMTA1MDM5My8yMDE3MDMvMTA1MDM5My0yMDE3MDMwODE5MDcyMjg5MS0xMjc5Nzk2NzE5LnBuZw?x-oss-process=image/format,png" srcset="/img/loading.gif" lazyload></p>
<p>　　通过上面的图片，可以发现non-blocking IO和asynchronous IO的区别还是很明显的。在non-blocking IO中，虽然进程大部分时间都不会被block，但是它仍然要求进程去主动的check，并且当数据准备完成以后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而asynchronous IO则完全不同。它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p>
<h2 id="IO多路复用之select、poll、epoll"><a href="#IO多路复用之select、poll、epoll" class="headerlink" title="IO多路复用之select、poll、epoll"></a>IO多路复用之select、poll、epoll</h2><p>　　select，poll，epoll都是IO多路复用的机制。I&#x2F;O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O则无需自己负责进行读写，异步I&#x2F;O的实现会负责把数据从内核拷贝到用户空间。</p>
<p><strong>select</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">select(rlist, wlist, xlist, timeout=None)<br></code></pre></td></tr></table></figure>

<p>　　select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>　　select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html">　　使用select库的一般步骤：创建所关注事件的描述集合。对于一个描述符，可以关注其上面的读事件、写事件以及异常发生事件，所以要创建三类事件描述符集合，分别用来收集读事件的描述符、写事件的描述符和异常事件的描述符。<br>　　其次，调用底层提供的select（）函数，等待事件的发生。select的阻塞与是否设置非阻塞的IO是没有关系的。<br>　　然后，轮询所有事件描述符集合中的每一个事件描述符，检查是否有响应的时间发生，如果有，则进行处理。<br>　　nginx服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。<br>　　可以使用--with-select_module和--without-select_module两个参数，强制nginx是否编译该库。<br><br>实例：<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">利用select通过单进程实现同时处理多个非阻塞的socket连接:<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># _*_coding:utf-8_*_</span><br><br><span class="hljs-keyword">import</span> select<br><span class="hljs-keyword">import</span> socket<br><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> queue<br><br><span class="hljs-comment"># Create a TCP/IP socket</span><br>server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)<br>server.setblocking(<span class="hljs-literal">False</span>)<br><br><span class="hljs-comment"># Bind the socket to the port</span><br>server_address = (<span class="hljs-string">&#x27;localhost&#x27;</span>, <span class="hljs-number">6666</span>)<br><span class="hljs-built_in">print</span>(sys.stderr, <span class="hljs-string">&#x27;starting up on %s port %s&#x27;</span> % server_address)<br>server.bind(server_address)<br><br><span class="hljs-comment"># Listen for incoming connections</span><br>server.listen(<span class="hljs-number">5</span>)<br><br><span class="hljs-comment"># Sockets from which we expect to read</span><br>inputs = [server]<br><br><span class="hljs-comment"># Sockets to which we expect to write</span><br>outputs = []<br><br>message_queues = &#123;&#125;<br><span class="hljs-keyword">while</span> inputs:<br>    <span class="hljs-comment"># Wait for at least one of the sockets to be ready for processing</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nwaiting for the next event&#x27;</span>)<br>    readable, writable, exceptional = select.select(inputs, outputs, inputs)<br>    <span class="hljs-comment"># Handle inputs</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> readable:<br>        <span class="hljs-keyword">if</span> s <span class="hljs-keyword">is</span> server:<br>            <span class="hljs-comment"># A &quot;readable&quot; server socket is ready to accept a connection</span><br>            connection, client_address = s.accept()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;new connection from&#x27;</span>, client_address)<br>            connection.setblocking(<span class="hljs-literal">False</span>)<br>            inputs.append(connection)<br><br>            <span class="hljs-comment"># Give the connection a queue for data we want to send</span><br>            message_queues[connection] = queue.Queue()<br>        <span class="hljs-keyword">else</span>:<br>            data = s.recv(<span class="hljs-number">1024</span>)<br>            <span class="hljs-keyword">if</span> data:<br>                <span class="hljs-comment"># A readable client socket has data</span><br>                <span class="hljs-built_in">print</span>(sys.stderr, <span class="hljs-string">&#x27;received &quot;%s&quot; from %s&#x27;</span> % (data, s.getpeername()))<br>                message_queues[s].put(data)<br>                <span class="hljs-comment"># Add output channel for response</span><br>                <span class="hljs-keyword">if</span> s <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> outputs:<br>                    outputs.append(s)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># Interpret empty result as closed connection</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;closing&#x27;</span>, client_address, <span class="hljs-string">&#x27;after reading no data&#x27;</span>)<br>                <span class="hljs-comment"># Stop listening for input on the connection</span><br>                <span class="hljs-keyword">if</span> s <span class="hljs-keyword">in</span> outputs:<br>                    outputs.remove(s)  <span class="hljs-comment"># 既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉</span><br>                inputs.remove(s)  <span class="hljs-comment"># inputs中也删除掉</span><br>                s.close()  <span class="hljs-comment"># 把这个连接关闭掉</span><br><br>                <span class="hljs-comment"># Remove message queue</span><br>                <span class="hljs-keyword">del</span> message_queues[s]<br>    <span class="hljs-comment"># Handle outputs</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> writable:<br>        <span class="hljs-keyword">try</span>:<br>            next_msg = message_queues[s].get_nowait()<br>        <span class="hljs-keyword">except</span> queue.Empty:<br>            <span class="hljs-comment"># No messages waiting so stop checking for writability.</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;output queue for&#x27;</span>, s.getpeername(), <span class="hljs-string">&#x27;is empty&#x27;</span>)<br>            outputs.remove(s)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;sending &quot;%s&quot; to %s&#x27;</span> % (next_msg, s.getpeername()))<br>            s.send(next_msg)<br>    <span class="hljs-comment"># Handle &quot;exceptional conditions&quot;</span><br>    <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> exceptional:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;handling exceptional condition for&#x27;</span>, s.getpeername())<br>        <span class="hljs-comment"># Stop listening for input on the connection</span><br>        inputs.remove(s)<br>        <span class="hljs-keyword">if</span> s <span class="hljs-keyword">in</span> outputs:<br>            outputs.remove(s)<br>        s.close()<br><br>        <span class="hljs-comment"># Remove message queue</span><br>        <span class="hljs-keyword">del</span> message_queues[s]<br></code></pre></td></tr></table></figure>

<p> </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env/ python</span><br><span class="hljs-comment"># -*-coding:utf-8 -*-</span><br><span class="hljs-keyword">import</span> socket,select,queue<br><span class="hljs-keyword">import</span> sys<br><br>server=socket.socket()<br>server.bind((<span class="hljs-string">&#x27;localhost&#x27;</span>,<span class="hljs-number">8080</span>))<br><br>server.listen(<span class="hljs-number">1000</span>)<br><br>server.setblocking(<span class="hljs-literal">False</span>)<span class="hljs-comment">#设置为非阻塞模式，socket必须在非阻塞情况下才能实现IO多路复用。</span><br><br><span class="hljs-comment">#需要监听的可读对象</span><br>inputs=[server,]<span class="hljs-comment">#存放selcct要监测的链接,一开始监测自己，有活动就表示有链接进来</span><br>outputs=[]<span class="hljs-comment">#这里存放的是内核返回的活跃的客户端连接，就是服务器需给send data的客户端连接</span><br><br>message_queues=&#123;&#125;<br><span class="hljs-keyword">while</span> inputs:<br>    <span class="hljs-comment"># Wait for at least one of the sockets to be ready for processing</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;\nwaiting for the next event&#x27;</span>)<br>    readable,writeable,exceptionable=select.select(inputs,outputs,inputs) <span class="hljs-comment">#此处会被select模块阻塞，只有当监听的三个参数发生变化时，select才会返,</span><br><br>    <span class="hljs-comment"># print(readable,writeable,exceptionable)</span><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> readable:<br>        <span class="hljs-keyword">if</span> r <span class="hljs-keyword">is</span> server:<span class="hljs-comment">#代表来了一个新连接</span><br>            conn,addr=server.accept()<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;来了一个新连接&quot;</span>,addr)<br>            inputs.append(conn)<span class="hljs-comment">#因为这个新建立的连接还没发数据过来，现在就接收的话会报错，所以要想客户端发数据过来时server端能知道，就要select监测这个连接。</span><br>            message_queues[conn]=queue.Queue()<span class="hljs-comment">#接收到客户端的数据后,不立刻返回 ,暂存在队列里,以后发送</span><br>        <span class="hljs-keyword">else</span>:<br>            data = r.recv(<span class="hljs-number">1024</span>) <span class="hljs-comment"># 注意这里是r，而不是conn，多个连接的情况</span><br>            <span class="hljs-keyword">if</span> data:<br>                <span class="hljs-comment"># A readable client socket has data</span><br>                <span class="hljs-built_in">print</span>(sys.stderr, <span class="hljs-string">&#x27;received &quot;%s&quot; from %s&#x27;</span> % (data, r.getpeername()))<br>                <span class="hljs-comment"># r.send(data) # 先不发，放到一个对列里，之后再发</span><br>                message_queues[r].put(data)<span class="hljs-comment"># 往里面放数据</span><br>                <span class="hljs-comment"># Add output channel for response</span><br>                <span class="hljs-keyword">if</span> r <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> outputs:<br>                    outputs.append(r)  <span class="hljs-comment">#放入返回的连接队列里</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># Interpret empty result as closed connection</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;closing&#x27;</span>, addr, <span class="hljs-string">&#x27;after reading no data&#x27;</span>)<br>                <span class="hljs-comment"># Stop listening for input on the connection</span><br>                <span class="hljs-keyword">if</span> r <span class="hljs-keyword">in</span> outputs:<br>                    outputs.remove(r)  <span class="hljs-comment"># 既然客户端都断开了，我就不用再给它返回数据了，所以这时候如果这个客户端的连接对象还在outputs列表中，就把它删掉</span><br>                inputs.remove(r)  <span class="hljs-comment"># inputs中也删除掉</span><br>                r.close()  <span class="hljs-comment"># 把这个连接关闭掉</span><br><br>                <span class="hljs-comment"># Remove message queue</span><br>                <span class="hljs-keyword">del</span> message_queues[r]<br><br>    <span class="hljs-keyword">for</span> w <span class="hljs-keyword">in</span> writeable:  <span class="hljs-comment"># 要返回给客户端的连接列表</span><br>        data_to_client = message_queues[w].get()  <span class="hljs-comment"># 在字典里取数据</span><br>        w.send(data_to_client)  <span class="hljs-comment"># 返回给客户端</span><br>        outputs.remove(w)  <span class="hljs-comment"># 删除这个数据，确保下次循环的时候不返回这个已经处理完的连接了。</span><br><br>    <span class="hljs-keyword">for</span> e <span class="hljs-keyword">in</span> exceptionable:  <span class="hljs-comment"># 如果连接断开，删除连接相关数据</span><br>        <span class="hljs-keyword">if</span> e <span class="hljs-keyword">in</span> outputs:<br>            outputs.remove(e)<br>        inputs.remove(e)<br>        <span class="hljs-keyword">del</span> message_queues[e]<br></code></pre></td></tr></table></figure>

<p><strong>poll</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">　　poll库，作为linux平台上的基本事件驱动模型，Windows平台不支持poll库。<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">　　使用poll库的一般过程是：与select的基本工作方式是相同的，都是先创建一个关注事件的描述符集合，再去等待这些事件的发生，然后在轮询描述符集合，检查有没有事件发生，如果有，就进行处理。<br>　　与select的主要区别是select需要为读事件、写事件、异常事件分别创建一个描述符的集合，因此在轮询的时候，需要分别轮询这三个集合。而poll库只需创建一个集合，在每个描述符对应的结构上分别设置读事件，写事件和异常事件，最后轮询的时候可以同时检查这三种事件是否发生。是select库优化的实现。<br>nginx服务器在编译过程中如果没有为其指定其他高性能事件驱动模型库，它将自动编译该库。可以使用--with-poll_module和--without-poll_module两个参数，强制nginx是否编译该库。<br></code></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html">int poll (struct pollfd *fds, unsigned int nfds, int timeout);<br></code></pre></td></tr></table></figure>

<p>　不同与select使用三个位图来表示三个fdset的方式，poll使用一个 pollfd的指针实现。　</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html">struct pollfd &#123;<br>    int fd; /* file descriptor */<br>    short events; /* requested events to watch */<br>    short revents; /* returned events witnessed */<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>　　pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</p>
<p>　　从上面看，select和poll都需要在返回后，<code>通过遍历文件描述符来获取已经就绪的socket</code>。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此随着监视的描述符数量的增长，其效率也会线性下降。</p>
<p><strong>epoll</strong></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">　　epoll是在2.6内核中提出的，是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。　  <br>　　epoll库是Nginx服务器支持的高性能事件之一，它是公认的非常优秀的时间驱动模型，和poll和select有很大的不同，属于poll库的一个变种，他们的处理方式都是创建一个待处理事件列表，然后把这个事件列表发送给内核，返回的时候，再去轮询检查这个列表，以判断事件是否发生。如果这样的描述符在比较多的应用中，效率就显得低下了，epoll是描述符列表的管理交给内核负责，一旦某种事件发生，内核会把发生事件的描述符列表通知给进程，这样就避免了轮询整个描述符列表，epoll库得到事件列表，就开始进行事件处理了。<br>　 注意：select和epoll最大的区别就是：select只是告诉你一定数目的流有事件了，至于哪个流有事件，还得你一个一个地去轮询，而 epoll会把发生的事件告诉你，通过发生的事件，就自然而然定位到哪个流了<br></code></pre></td></tr></table></figure>

<p>一 epoll操作过程</p>
<p>epoll操作过程需要三个接口，分别如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大<br>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br></code></pre></td></tr></table></figure>

<p>1. int epoll_create(int size);<br>　　创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<code>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议</code>。<br>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看&#x2F;proc&#x2F;进程id&#x2F;fd&#x2F;，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；<br>　　函数是对指定描述符fd执行op操作。<br>　 - epfd：是epoll_create()的返回值。<br>　 - op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。<br>　 - fd：是需要监听的fd（文件描述符）<br>　 - epoll_event：是告诉内核需要监听什么事</p>
<p>3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);<br>　　等待epfd上的io事件，最多返回maxevents个事件。<br>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> socket, logging<br><span class="hljs-keyword">import</span> select, errno<br><br>logger = logging.getLogger(<span class="hljs-string">&quot;network-server&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">InitLog</span>():<br>    logger.setLevel(logging.DEBUG)<br><br>    fh = logging.FileHandler(<span class="hljs-string">&quot;network-server.log&quot;</span>)<br>    fh.setLevel(logging.DEBUG)<br>    ch = logging.StreamHandler()<br>    ch.setLevel(logging.ERROR)<br><br>    formatter = logging.Formatter(<span class="hljs-string">&quot;%(asctime)s - %(name)s - %(levelname)s - %(message)s&quot;</span>)<br>    ch.setFormatter(formatter)<br>    fh.setFormatter(formatter)<br><br>    logger.addHandler(fh)<br>    logger.addHandler(ch)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    InitLog()<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 创建 TCP socket 作为监听 socket</span><br>        listen_fd = socket.socket(socket.AF_INET, socket.SOCK_STREAM, <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span>  msg:<br>        logger.error(<span class="hljs-string">&quot;create socket failed&quot;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 设置 SO_REUSEADDR 选项</span><br>        listen_fd.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span>  msg:<br>        logger.error(<span class="hljs-string">&quot;setsocketopt SO_REUSEADDR failed&quot;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 进行 bind -- 此处未指定 ip 地址，即 bind 了全部网卡 ip 上</span><br>        listen_fd.bind((<span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-number">2003</span>))<br>    <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span>  msg:<br>        logger.error(<span class="hljs-string">&quot;bind failed&quot;</span>)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 设置 listen 的 backlog 数</span><br>        listen_fd.listen(<span class="hljs-number">10</span>)<br>    <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span>  msg:<br>        logger.error(msg)<br><br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 创建 epoll 句柄</span><br>        epoll_fd = select.epoll()<br>        <span class="hljs-comment"># 向 epoll 句柄中注册 监听 socket 的 可读 事件</span><br>        epoll_fd.register(listen_fd.fileno(), select.EPOLLIN)<br>    <span class="hljs-keyword">except</span> select.error <span class="hljs-keyword">as</span>  msg:<br>        logger.error(msg)<br><br>    connections = &#123;&#125;<br>    addresses = &#123;&#125;<br>    datalist = &#123;&#125;<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-comment"># epoll 进行 fd 扫描的地方 -- 未指定超时时间则为阻塞等待</span><br>        epoll_list = epoll_fd.poll()<br><br>        <span class="hljs-keyword">for</span> fd, events <span class="hljs-keyword">in</span> epoll_list:<br>            <span class="hljs-comment"># 若为监听 fd 被激活</span><br>            <span class="hljs-keyword">if</span> fd == listen_fd.fileno():<br>                <span class="hljs-comment"># 进行 accept -- 获得连接上来 client 的 ip 和 port，以及 socket 句柄</span><br>                conn, addr = listen_fd.accept()<br>                logger.debug(<span class="hljs-string">&quot;accept connection from %s, %d, fd = %d&quot;</span> % (addr[<span class="hljs-number">0</span>], addr[<span class="hljs-number">1</span>], conn.fileno()))<br>                <span class="hljs-comment"># 将连接 socket 设置为 非阻塞</span><br>                conn.setblocking(<span class="hljs-number">0</span>)<br>                <span class="hljs-comment"># 向 epoll 句柄中注册 连接 socket 的 可读 事件</span><br>                epoll_fd.register(conn.fileno(), select.EPOLLIN | select.EPOLLET)<br>                <span class="hljs-comment"># 将 conn 和 addr 信息分别保存起来</span><br>                connections[conn.fileno()] = conn<br>                addresses[conn.fileno()] = addr<br>            <span class="hljs-keyword">elif</span> select.EPOLLIN &amp; events:<br>                <span class="hljs-comment"># 有 可读 事件激活</span><br>                datas = <span class="hljs-string">&#x27;&#x27;</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    <span class="hljs-keyword">try</span>:<br>                        <span class="hljs-comment"># 从激活 fd 上 recv 10 字节数据</span><br>                        data = connections[fd].recv(<span class="hljs-number">10</span>)<br>                        <span class="hljs-comment"># 若当前没有接收到数据，并且之前的累计数据也没有</span><br>                        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> data <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> datas:<br>                            <span class="hljs-comment"># 从 epoll 句柄中移除该 连接 fd</span><br>                            epoll_fd.unregister(fd)<br>                            <span class="hljs-comment"># server 侧主动关闭该 连接 fd</span><br>                            connections[fd].close()<br>                            logger.debug(<span class="hljs-string">&quot;%s, %d closed&quot;</span> % (addresses[fd][<span class="hljs-number">0</span>], addresses[fd][<span class="hljs-number">1</span>]))<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">else</span>:<br>                            <span class="hljs-comment"># 将接收到的数据拼接保存在 datas 中</span><br>                            datas += data<br>                    <span class="hljs-keyword">except</span> socket.error <span class="hljs-keyword">as</span>  msg:<br>                        <span class="hljs-comment"># 在 非阻塞 socket 上进行 recv 需要处理 读穿 的情况</span><br>                        <span class="hljs-comment"># 这里实际上是利用 读穿 出 异常 的方式跳到这里进行后续处理</span><br>                        <span class="hljs-keyword">if</span> msg.errno == errno.EAGAIN:<br>                            logger.debug(<span class="hljs-string">&quot;%s receive %s&quot;</span> % (fd, datas))<br>                            <span class="hljs-comment"># 将已接收数据保存起来</span><br>                            datalist[fd] = datas<br>                            <span class="hljs-comment"># 更新 epoll 句柄中连接d 注册事件为 可写</span><br>                            epoll_fd.modify(fd, select.EPOLLET | select.EPOLLOUT)<br>                            <span class="hljs-keyword">break</span><br>                        <span class="hljs-keyword">else</span>:<br>                            <span class="hljs-comment"># 出错处理</span><br>                            epoll_fd.unregister(fd)<br>                            connections[fd].close()<br>                            logger.error(msg)<br>                            <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">elif</span> select.EPOLLHUP &amp; events:<br>                <span class="hljs-comment"># 有 HUP 事件激活</span><br>                epoll_fd.unregister(fd)<br>                connections[fd].close()<br>                logger.debug(<span class="hljs-string">&quot;%s, %d closed&quot;</span> % (addresses[fd][<span class="hljs-number">0</span>], addresses[fd][<span class="hljs-number">1</span>]))<br>            <span class="hljs-keyword">elif</span> select.EPOLLOUT &amp; events:<br>                <span class="hljs-comment"># 有 可写 事件激活</span><br>                sendLen = <span class="hljs-number">0</span><br>                <span class="hljs-comment"># 通过 while 循环确保将 buf 中的数据全部发送出去</span><br>                <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>                    <span class="hljs-comment"># 将之前收到的数据发回 client -- 通过 sendLen 来控制发送位置</span><br>                    sendLen += connections[fd].send(datalist[fd][sendLen:])<br>                    <span class="hljs-comment"># 在全部发送完毕后退出 while 循环</span><br>                    <span class="hljs-keyword">if</span> sendLen == <span class="hljs-built_in">len</span>(datalist[fd]):<br>                        <span class="hljs-keyword">break</span><br>                <span class="hljs-comment"># 更新 epoll 句柄中连接 fd 注册事件为 可读</span><br>                epoll_fd.modify(fd, select.EPOLLIN | select.EPOLLET)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 其他 epoll 事件不进行处理</span><br>                <span class="hljs-keyword">continue</span><br></code></pre></td></tr></table></figure>

<hr>
<h3 id="select-amp-poll-amp-epoll比较"><a href="#select-amp-poll-amp-epoll比较" class="headerlink" title="select &amp; poll &amp; epoll比较"></a>select &amp; poll &amp; epoll比较</h3><ul>
<li>每次调用 <code>select</code> 都需要把所有要监听的文件描述符拷贝到内核空间一次，fd很大时开销会很大。 <code>epoll</code> 会在epoll_ctl()中注册，只需要将所有的fd拷贝到内核事件表一次，不用再每次epoll_wait()时重复拷贝</li>
<li>每次 <code>select</code> 需要在内核中遍历所有监听的fd，直到设备就绪； <code>epoll</code> 通过 <code>epoll_ctl</code> 注册回调函数，也需要不断调用 <code>epoll_wait</code> 轮询就绪链表，当fd或者事件就绪时，会调用回调函数，将就绪结果加入到就绪链表。</li>
<li><code>select</code> 能监听的文件描述符数量有限，默认是1024； <code>epoll</code> 能支持的fd数量是最大可以打开文件的数目，具体数目可以在&#x2F;proc&#x2F;sys&#x2F;fs&#x2F;file-max查看</li>
<li><code>select</code> , <code>poll</code> 在函数返回后需要查看所有监听的fd，看哪些就绪，而epoll只返回就绪的描述符，所以应用程序只需要就绪fd的命中率是百分百。</li>
</ul>
<p>表面上看epoll的性能最好，但是在连接数少并且链接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</p>
<p>select效率低是一位每次都需要轮询，但效率低也是相对的，也可通过良好的设计改善</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/freely/p/6522432.html">https://www.cnblogs.com/freely/p/6522432.html</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/python%E5%8A%A0%E6%B2%B9%E9%B8%AD/" class="category-chain-item">python加油鸭</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/epoll-python-linux/">#epoll python linux</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Python IO模型（阻塞、非阻塞、多路复用与异步）</div>
      <div>https://waym1ng.github.io/2020/04/29/Python IO模型（阻塞、非阻塞、多路复用与异步）/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>waymingz</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2020年4月29日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/04/29/selector%20Python%20selectors%E6%A8%A1%E5%9D%97%20I!O%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" title="selector Python selectors模块 I/O多路复用">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">selector Python selectors模块 I/O多路复用</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/04/17/Ubuntu16.04%20%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99/" title="Ubuntu16.04 关闭防火墙">
                        <span class="hidden-mobile">Ubuntu16.04 关闭防火墙</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://lib.baomitu.com/valine/1.4.17/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"QaAc8EraW3qDuc3hldMvmw5p-gzGzoHsz","appKey":"oTgXIx2IwXcYJAPXLGPAdYJC","path":"window.location.pathname","placeholder":null,"avatar":"retro","meta":["nick","mail","link"],"requiredFields":[],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"","emojiCDN":null,"emojiMaps":null,"enableQQ":false},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
        Fluid.utils.waitElementVisible('#valine .vcontent', () => {
          var imgSelector = '#valine .vcontent img:not(.vemoji)';
          Fluid.plugins.imageCaption(imgSelector);
          Fluid.plugins.fancyBox(imgSelector);
        })
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  
</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP证123456号
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=12345678"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>京公网安备12345678号</span>
        </a>
      </span>
    
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
